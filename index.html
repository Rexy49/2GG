<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 4x4 Grid Comparator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
        }
        .grid-container {
            width: 48%;
        }
        h2 {
            text-align: center;
            color: #333;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-bottom: 15px;
        }
        .cell {
            border: 1px solid #ccc;
            padding: 15px;
            text-align: center;
            font-weight: bold;
            background-color: #f9f9f9;
        }
        .cell input {
            width: 30px;
            text-align: center;
            font-weight: bold;
            border: none;
            background: transparent;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        button {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        .stats {
            text-align: center;
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        .highlight {
            background-color: #ffeb3b;
            animation: pulse 1s;
        }
        @keyframes pulse {
            0% { background-color: #ffeb3b; }
            50% { background-color: #ffc107; }
            100% { background-color: #ffeb3b; }
        }
        .comparison-results {
            margin-top: 30px;
            padding: 15px;
            background-color: #e9f7ef;
            border-radius: 5px;
        }
        .match-item {
            margin-bottom: 10px;
            padding: 10px;
            background-color: #e3f2fd;
            border-radius: 3px;
        }
        .search-container {
            margin: 20px 0;
            padding: 15px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }
        .search-container input {
            padding: 8px;
            width: 200px;
            margin-right: 10px;
        }
        .search-results {
            margin-top: 10px;
        }
        .search-match {
            padding: 5px;
            background-color: #fff;
            margin: 3px 0;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>Enhanced 4x4 Grid Permutation Comparator</h1>
    
    <div class="controls">
        <button id="compareBtn">Compare Permutations</button>
        <button id="clearBtn">Clear All</button>
        <button id="exampleBtn">Load Example</button>
    </div>
    
    <div class="container">
        <div class="grid-container">
            <h2>Grid 1</h2>
            <div class="grid" id="grid1"></div>
        </div>
        
        <div class="grid-container">
            <h2>Grid 2</h2>
            <div class="grid" id="grid2"></div>
        </div>
    </div>
    
    <div class="search-container">
        <h3>Pattern Search</h3>
        <input type="text" id="searchInput" placeholder="Enter number or pattern (e.g., 123 or 1-2-3)">
        <button id="searchBtn">Search</button>
        <div class="search-results" id="searchResults"></div>
    </div>
    
    <div class="comparison-results">
        <h3>Permutation Comparison Results</h3>
        <div id="comparisonResults"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const grid1 = document.getElementById('grid1');
            const grid2 = document.getElementById('grid2');
            const compareBtn = document.getElementById('compareBtn');
            const clearBtn = document.getElementById('clearBtn');
            const exampleBtn = document.getElementById('exampleBtn');
            const searchBtn = document.getElementById('searchBtn');
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');
            const comparisonResults = document.getElementById('comparisonResults');
            
            // Initialize grids with input cells
            function initializeGrid(gridElement, rows, cols) {
                gridElement.innerHTML = '';
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.maxLength = 1;
                        input.dataset.row = i;
                        input.dataset.col = j;
                        cell.appendChild(input);
                        gridElement.appendChild(cell);
                    }
                }
            }
            
            // Get grid data as 2D array
            function getGridData(gridElement) {
                const inputs = gridElement.querySelectorAll('input');
                const data = [[], [], [], []];
                inputs.forEach(input => {
                    const row = parseInt(input.dataset.row);
                    const col = parseInt(input.dataset.col);
                    data[row][col] = input.value !== '' ? parseInt(input.value) : 0;
                });
                return data;
            }
            
            // Compare permutations between grids
            function comparePermutations() {
                removeHighlights();
                
                const grid1Data = getGridData(grid1);
                const grid2Data = getGridData(grid2);
                
                // Analyze permutation types for each grid
                const grid1Perms = analyzePermutations(grid1Data);
                const grid2Perms = analyzePermutations(grid2Data);
                
                // Compare grids and find matching permutations
                const matches = findMatchingPermutations(grid1Perms, grid2Perms);
                
                // Highlight matching permutations
                highlightMatchingPermutations(grid1, grid1Perms, matches);
                highlightMatchingPermutations(grid2, grid2Perms, matches);
                
                // Display simplified comparison results
                displayComparisonResults(matches);
            }
            
            // Analyze permutation types in a grid
            function analyzePermutations(gridData) {
                const permutations = [];
                
                gridData.forEach(row => {
                    const sorted = [...row].sort((a, b) => a - b);
                    const key = sorted.join(',');
                    const uniqueValues = new Set(sorted);
                    const countMap = {};
                    
                    sorted.forEach(num => {
                        countMap[num] = (countMap[num] || 0) + 1;
                    });
                    
                    const counts = Object.values(countMap).sort((a, b) => b - a);
                    const type = getPermutationType(counts);
                    
                    permutations.push({
                        original: [...row],
                        sorted: sorted,
                        key: key,
                        type: type,
                        counts: counts
                    });
                });
                
                return permutations;
            }
            
            // Determine permutation type based on counts
            function getPermutationType(counts) {
                if (counts[0] === 4) return "All identical (1)";
                if (counts[0] === 3) return "Three identical (4)";
                if (counts[0] === 2 && counts[1] === 2) return "Two pairs (6)";
                if (counts[0] === 2) return "One pair (12)";
                return "All unique (24)";
            }
            
            // Find matching permutations between grids
            function findMatchingPermutations(perms1, perms2) {
                const matches = {};
                
                perms1.forEach((perm1, i) => {
                    perms2.forEach((perm2, j) => {
                        if (perm1.key === perm2.key) {
                            if (!matches[perm1.key]) {
                                matches[perm1.key] = {
                                    type: perm1.type,
                                    sorted: perm1.sorted,
                                    grid1Rows: [],
                                    grid2Rows: []
                                };
                            }
                            matches[perm1.key].grid1Rows.push(i+1);
                            matches[perm1.key].grid2Rows.push(j+1);
                        }
                    });
                });
                
                return matches;
            }
            
            // Highlight matching permutations in a grid
            function highlightMatchingPermutations(gridElement, perms, matches) {
                const cells = gridElement.querySelectorAll('.cell');
                
                Object.keys(matches).forEach(key => {
                    const match = matches[key];
                    
                    // For grid1
                    if (gridElement === grid1) {
                        match.grid1Rows.forEach(row => {
                            for (let col = 0; col < 4; col++) {
                                const index = (row-1) * 4 + col;
                                cells[index].classList.add('highlight');
                            }
                        });
                    }
                    // For grid2
                    else {
                        match.grid2Rows.forEach(row => {
                            for (let col = 0; col < 4; col++) {
                                const index = (row-1) * 4 + col;
                                cells[index].classList.add('highlight');
                            }
                        });
                    }
                });
            }
            
            // Display simplified comparison results
            function displayComparisonResults(matches) {
                comparisonResults.innerHTML = '';
                
                if (Object.keys(matches).length === 0) {
                    comparisonResults.innerHTML = '<p>No matching permutations found between grids.</p>';
                    return;
                }
                
                Object.keys(matches).forEach(key => {
                    const match = matches[key];
                    const div = document.createElement('div');
                    div.className = 'match-item';
                    div.innerHTML = `
                        <strong>${match.type}</strong><br>
                        <strong>Pattern:</strong> [${match.sorted.join(', ')}]<br>
                        <strong>Grid 1 rows:</strong> ${match.grid1Rows.join(', ')}<br>
                        <strong>Grid 2 rows:</strong> ${match.grid2Rows.join(', ')}
                    `;
                    comparisonResults.appendChild(div);
                });
            }
            
            // Search for patterns in grids
            function searchPatterns() {
                const searchTerm = searchInput.value.trim();
                if (!searchTerm) return;
                
                const grid1Data = getGridData(grid1);
                const grid2Data = getGridData(grid2);
                
                // Normalize search term (handle both "123" and "1-2-3" formats)
                const searchPattern = searchTerm.includes('-') 
                    ? searchTerm.split('-').map(Number)
                    : searchTerm.split('').map(Number);
                
                searchResults.innerHTML = '';
                
                // Search in Grid 1
                const grid1Matches = findPatternInGrid(grid1Data, searchPattern);
                if (grid1Matches.length > 0) {
                    const div = document.createElement('div');
                    div.className = 'search-match';
                    div.innerHTML = `<strong>Grid 1 matches:</strong> ${grid1Matches.join(', ')}`;
                    searchResults.appendChild(div);
                }
                
                // Search in Grid 2
                const grid2Matches = findPatternInGrid(grid2Data, searchPattern);
                if (grid2Matches.length > 0) {
                    const div = document.createElement('div');
                    div.className = 'search-match';
                    div.innerHTML = `<strong>Grid 2 matches:</strong> ${grid2Matches.join(', ')}`;
                    searchResults.appendChild(div);
                }
                
                if (grid1Matches.length === 0 && grid2Matches.length === 0) {
                    searchResults.innerHTML = '<div class="search-match">No matches found for this pattern</div>';
                }
            }
            
            // Find pattern in a grid (2D/3D search)
            function findPatternInGrid(gridData, pattern) {
                const matches = [];
                const patternStr = pattern.join('');
                
                // Check rows
                gridData.forEach((row, rowIndex) => {
                    const rowStr = row.join('');
                    if (rowStr.includes(patternStr)) {
                        matches.push(`Row ${rowIndex+1}`);
                    }
                });
                
                // Check columns
                for (let col = 0; col < 4; col++) {
                    let colStr = '';
                    for (let row = 0; row < 4; row++) {
                        colStr += gridData[row][col];
                    }
                    if (colStr.includes(patternStr)) {
                        matches.push(`Column ${col+1}`);
                    }
                }
                
                // Check diagonals (top-left to bottom-right)
                let diag1Str = '';
                for (let i = 0; i < 4; i++) {
                    diag1Str += gridData[i][i];
                }
                if (diag1Str.includes(patternStr)) {
                    matches.push(`Diagonal 1 (TL-BR)`);
                }
                
                // Check diagonals (top-right to bottom-left)
                let diag2Str = '';
                for (let i = 0; i < 4; i++) {
                    diag2Str += gridData[i][3-i];
                }
                if (diag2Str.includes(patternStr)) {
                    matches.push(`Diagonal 2 (TR-BL)`);
                }
                
                return matches;
            }
            
            function removeHighlights() {
                document.querySelectorAll('.highlight').forEach(el => {
                    el.classList.remove('highlight');
                });
            }
            
            function clearAll() {
                initializeGrid(grid1, 4, 4);
                initializeGrid(grid2, 4, 4);
                comparisonResults.innerHTML = '';
                searchResults.innerHTML = '';
                searchInput.value = '';
                removeHighlights();
            }
            
            function loadExample() {
                clearAll();
                
                // Example data with various permutation types
                const exampleGrid1 = [
                    [2, 3, 4, 5], // All unique (24)
                    [6, 8, 7, 8], // One pair (12)
                    [1, 1, 2, 2], // Two pairs (6)
                    [3, 3, 3, 1], // Three identical (4)
                    [4, 4, 4, 4]  // All identical (1)
                ];
                
                const exampleGrid2 = [
                    [5, 4, 3, 2], // Same as grid1 row1 when sorted
                    [8, 7, 8, 6], // Same as grid1 row2 when sorted
                    [2, 1, 2, 1], // Same as grid1 row3 when sorted
                    [1, 3, 3, 3], // Same as grid1 row4 when sorted
                    [4, 4, 4, 4]  // Same as grid1 row5 when sorted
                ];
                
                // Fill grid1
                const inputs1 = grid1.querySelectorAll('input');
                exampleGrid1.forEach((row, i) => {
                    row.forEach((val, j) => {
                        const index = i * 4 + j;
                        if (inputs1[index]) inputs1[index].value = val;
                    });
                });
                
                // Fill grid2
                const inputs2 = grid2.querySelectorAll('input');
                exampleGrid2.forEach((row, i) => {
                    row.forEach((val, j) => {
                        const index = i * 4 + j;
                        if (inputs2[index]) inputs2[index].value = val;
                    });
                });
            }
            
            // Event listeners
            compareBtn.addEventListener('click', comparePermutations);
            clearBtn.addEventListener('click', clearAll);
            exampleBtn.addEventListener('click', loadExample);
            searchBtn.addEventListener('click', searchPatterns);
            searchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') searchPatterns();
            });
            
            // Initialize
            initializeGrid(grid1, 4, 4);
            initializeGrid(grid2, 4, 4);
        });
    </script>
</body>
</html>
